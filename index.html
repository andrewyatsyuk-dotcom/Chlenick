```html
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçÜ –í–∏—Ä–æ—â—É–≤–∞—á –ß–ª–µ–Ω–∞ ‚Äî Telegram Bot</title>
    <style>
        body { font-family: system-ui, sans-serif; background: #0f001a; color: #ffccff; text-align: center; padding: 20px; }
        pre { background: #1a0033; padding: 20px; border-radius: 12px; text-align: left; max-width: 800px; margin: 20px auto; overflow-x: auto; }
        h1 { color: #ff00ff; text-shadow: 0 0 20px #ff00ff; }
        code { color: #00ffcc; }
        .warning { color: #ffff00; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üçÜ –í–ò–†–û–©–£–í–ê–ß –ß–õ–ï–ù–ê –î–õ–Ø TELEGRAM –ë–û–¢–ê</h1>
    <p>–¢–µ–ø–µ—Ä –≥—Ä–∞ –ø–æ–≤–Ω—ñ—Å—Ç—é –¥–ª—è Telegram! –ö–æ–∂–µ–Ω –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –º–∞—î —Å–≤—ñ–π —á–ª–µ–Ω, —î –≥–ª–æ–±–∞–ª—å–Ω–∏–π –¢–û–ü-15, –∑–º–∞–≥–∞–π—Ç–µ—Å—è –∑ –¥—Ä—É–∑—è–º–∏ —á–µ—Ä–µ–∑ /top</p>
    <p class="warning">–ü–∞—Å–∏–≤–Ω–∏–π —Ä—ñ—Å—Ç 0.4 —Å–º/–≥–æ–¥–∏–Ω—É –Ω–∞–≤—ñ—Ç—å –∫–æ–ª–∏ –±–æ—Ç –≤–∏–º–∫–Ω–µ–Ω–∏–π!</p>

    <h2>–Ø–∫ –∑–∞–ø—É—Å—Ç–∏—Ç–∏ –∑–∞ 3 —Ö–≤–∏–ª–∏–Ω–∏:</h2>
    <ol style="max-width:700px; margin:0 auto; text-align:left;">
        <li>–ù–∞–ø–∏—à–∏ @BotFather ‚Üí /newbot ‚Üí –ø—Ä–∏–¥—É–º–∞–π –Ω–∞–∑–≤—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ MyDickGrowerBot) ‚Üí –æ—Ç—Ä–∏–º–∞–π TOKEN</li>
        <li>–í—Å—Ç–∞–≤ —Ü–µ–π TOKEN —É –∫–æ–¥ –∑–∞–º—ñ—Å—Ç—å <code>YOUR_TOKEN_HERE</code></li>
        <li>–í—Å—Ç–∞–Ω–æ–≤–∏ Python 3.10+ —ñ –≤–∏–∫–æ–Ω–∞–π —É —Ç–µ—Ä–º—ñ–Ω–∞–ª—ñ: <code>pip install aiogram</code></li>
        <li>–ó–±–µ—Ä–µ–∂–∏ –∫–æ–¥ –Ω–∏–∂—á–µ —è–∫ <code>bot.py</code></li>
        <li>–ó–∞–ø—É—Å—Ç–∏: <code>python bot.py</code></li>
        <li>–î–æ–¥–∞–π –±–æ—Ç–∞ –¥–æ —á–∞—Ç—É –∑ –¥—Ä—É–∑—è–º–∏ –∞–±–æ –Ω–∞–¥—ñ—à–ª–∏ —ó–º –ø–æ—Å–∏–ª–∞–Ω–Ω—è ‚Äî —ñ –∑–º–∞–≥–∞–π—Ç–µ—Å—è!</li>
    </ol>

    <h2>–ö–æ–º–∞–Ω–¥–∏ –±–æ—Ç–∞:</h2>
    <p><b>/start</b> ‚Äî –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é –∑ –∫–Ω–æ–ø–∫–∞–º–∏<br>
       <b>/top</b> ‚Äî –≥–ª–æ–±–∞–ª—å–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥ (—Ç–æ–ø-15)<br>
       –ö–Ω–æ–ø–∫–∏: –ü–Ü–î–ö–ê–ß–ê–¢–ò, –ü–û–ë–†–ò–¢–ò, –ú–ê–°–ê–ñ, –¢–†–ï–ù–£–í–ê–ù–ù–Ø</p>

<pre><code>import asyncio
import json
import os
import time
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery

BOT_TOKEN = "YOUR_TOKEN_HERE"   # ‚Üê‚Üê‚Üê –ó–ê–ú–Ü–ù–ò –ù–ê –°–í–Ü–ô –¢–û–ö–ï–ù

bot = Bot(token=BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher()

DATA_FILE = "dick_growers.json"
users = {}

PASSIVE_PER_HOUR = 0.4
COOLDOWNS = {"pump": 4*3600, "shave": 24*3600, "massage": 30*60, "exercise": 3600}
BOOSTS = {"pump": 50, "shave": 20, "massage": 3, "exercise": 8}

def load_data():
    global users
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                users = json.load(f)
        except:
            users = {}
    else:
        users = {}

def save_data():
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(users, f, ensure_ascii=False, indent=2)

async def show_status(chat_id: int, user_id: str, to_edit: types.Message = None):
    user = users[user_id]
    length = round(user["length"], 1)
    percent = min(100, length / 10)
    filled = int(percent / 5)
    bar = "‚ñà" * filled + "‚ñë" * (20 - filled)
    
    status = " üèÜ –õ–ï–ì–ï–ù–î–ê 1000+ —Å–º!" if length >= 1000 else ""
    
    text = f"""üçÜ <b>–í–∏—Ä–æ—â—É–≤–∞—á –ß–ª–µ–Ω–∞</b>{status}

<b>–î–æ–≤–∂–∏–Ω–∞:</b> {length} —Å–º
–ü—Ä–æ–≥—Ä–µ—Å –¥–æ 1000 —Å–º: [{bar}] {percent:.0f}%

–û–±–µ—Ä–∏ –¥—ñ—é:"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí¶ –ü–Ü–î–ö–ê–ß–ê–¢–ò (+50—Å–º, 4–≥)", callback_data="pump")],
        [InlineKeyboardButton(text="ü™í –ü–û–ë–†–ò–¢–ò (+20—Å–º, 24–≥)", callback_data="shave")],
        [InlineKeyboardButton(text="üñêÔ∏è –ú–ê–°–ê–ñ (+3—Å–º, 30—Ö–≤)", callback_data="massage")],
        [InlineKeyboardButton(text="üèãÔ∏è –¢–†–ï–ù–£–í–ê–¢–ò (+8—Å–º, 1–≥)", callback_data="exercise")],
    ])

    if to_edit:
        await to_edit.edit_text(text, reply_markup=keyboard)
    else:
        await bot.send_message(chat_id, text, reply_markup=keyboard)

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    user_id = str(message.from_user.id)
    full_name = message.from_user.full_name

    if user_id not in users:
        users[user_id] = {
            "length": 0.0,
            "last_check": time.time(),
            "last_pump": 0,
            "last_shave": 0,
            "last_massage": 0,
            "last_exercise": 0,
            "display_name": full_name
        }
    else:
        users[user_id]["display_name"] = full_name

    # –ø–∞—Å–∏–≤–Ω–∏–π —Ä—ñ—Å—Ç –æ—Ñ–ª–∞–π–Ω
    now = time.time()
    last_check = users[user_id].get("last_check", now)
    hours_off = (now - last_check) / 3600
    users[user_id]["length"] += hours_off * PASSIVE_PER_HOUR
    users[user_id]["last_check"] = now

    save_data()
    await show_status(message.chat.id, user_id)

@dp.callback_query(lambda c: c.data in ["pump", "shave", "massage", "exercise"])
async def handle_action(callback: CallbackQuery):
    user_id = str(callback.from_user.id)
    full_name = callback.from_user.full_name
    action = callback.data

    if user_id not in users:
        users[user_id] = {
            "length": 0.0,
            "last_check": time.time(),
            "last_pump": 0, "last_shave": 0,
            "last_massage": 0, "last_exercise": 0,
            "display_name": full_name
        }
    else:
        users[user_id]["display_name"] = full_name

    now = time.time()

    # –ø–∞—Å–∏–≤–Ω–∏–π —Ä—ñ—Å—Ç
    last_check = users[user_id].get("last_check", now)
    hours_off = (now - last_check) / 3600
    users[user_id]["length"] += hours_off * PASSIVE_PER_HOUR
    users[user_id]["last_check"] = now

    # –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω—É
    last_time = users[user_id].get(f"last_{action}", 0)
    cd = COOLDOWNS[action]
    if now - last_time < cd:
        remain = cd - (now - last_time)
        h = int(remain // 3600)
        m = int((remain % 3600) // 60)
        await callback.answer(f"‚è≥ –©–µ —Ä–∞–Ω–æ! –ß–µ–∫–∞–π {h}–≥ {m}—Ö–≤", show_alert=True)
        return

    # –≤–∏–∫–æ–Ω—É—î–º–æ –¥—ñ—é
    boost = BOOSTS[action]
    users[user_id]["length"] += boost
    users[user_id][f"last_{action}"] = now
    users[user_id]["last_check"] = now

    save_data()

    await callback.answer(f"‚úÖ +{boost} —Å–º! –¢–µ–ø–µ—Ä {round(users[user_id]['length'],1)} —Å–º üçÜ", show_alert=False)
    await show_status(callback.message.chat.id, user_id, callback.message)

@dp.message(Command("top"))
async def cmd_top(message: types.Message):
    if not users:
        await message.answer("–ü–æ–∫–∏ –Ω—ñ—Ö—Ç–æ –Ω–µ —Ä–æ—Å—Ç–µ üò¢ –ü–æ—á–Ω–∏ –ø–µ—Ä—à–∏–º!")
        return

    top_list = sorted(users.items(), key=lambda x: x[1]["length"], reverse=True)[:15]

    text = "üèÜ <b>–ì–õ–û–ë–ê–õ–¨–ù–ò–ô –¢–û–ü-15 –í–ò–†–û–©–£–í–ê–ß–Ü–í</b>\n\n"
    for rank, (uid, data) in enumerate(top_list, 1):
        name = data.get("display_name", "–ê–Ω–æ–Ω")
        length = round(data["length"], 1)
        text += f"<b>{rank}.</b> {name} ‚Äî <b>{length}</b> —Å–º\n"

    text += "\n\n–ó–º–∞–≥–∞–π—Å—è –∑ –¥—Ä—É–∑—è–º–∏! –ù–∞–¥—ñ—à–ª–∏ —ó–º –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –±–æ—Ç–∞ üëá"
    await message.answer(text, disable_web_page_preview=True)

async def main():
    load_data()
    print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω–æ! –í–∏—Ä–æ—â—É–π —ñ –∑–º–∞–≥–∞–π—Å—è!")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
</code></pre>

<p><b>–ì–æ—Ç–æ–≤–æ!</b> –ü—ñ—Å–ª—è –∑–∞–ø—É—Å–∫—É –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –±–æ—Ç—É /start —ñ –ø–æ—á–∏–Ω–∞–π —Ä–æ—Å—Ç–∏. –î—Ä—É–∑—ñ —Ç–µ–∂ –∑–∞–ø—É—Å–∫–∞—é—Ç—å ‚Äî —ñ –¥–∏–≤—ñ—Ç—å—Å—è /top üî•</p>
<p>–•–æ—á–µ—à –¥–æ–¥–∞—Ç–∏ —â–æ—Å—å (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥ –ø—Ä–∏–≤–∞—Ç–Ω—ñ —á–µ–ª–µ–Ω–¥–∂—ñ –º—ñ–∂ –¥—Ä—É–∑—è–º–∏ –∞–±–æ –∫–∞—Ä—Ç–∏–Ω–∫—É —á–ª–µ–Ω–∞) ‚Äî –ø–∏—à–∏, –∑—Ä–æ–±–ª—é –∑–∞ 5 —Ö–≤–∏–ª–∏–Ω.</p>
</body>
</html>
```
