<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grow Your Dick</title>
<script src="https://telegram.org/js/telegram-web-app.js" async></script>
<style>
  :root {
    --bg: #87CEEB;
    --grass: #4CAF50;
    --text: #1a1a2e;
    --card: rgba(255,255,255,0.85);
    --card-border: rgba(255,255,255,0.5);
    --shadow: rgba(0,0,0,0.15);
  }
  [data-theme="dark"] {
    --bg: #1a1a2e;
    --grass: #2d5a27;
    --text: #e0e0e0;
    --card: rgba(30,30,50,0.9);
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
  #app { display: flex; flex-direction: column; min-height: 100vh; padding: 16px; }
  #header { text-align: center; padding: 12px 0; }
  #header h1 { font-size: 1.5rem; font-weight: 900; }
  #size-display { font-size: 1.2rem; margin-top: 4px; }
  #size-display span { font-weight: 900; transition: transform 0.15s; }
  #size-display span.grow-pop { animation: growPop 0.4s ease-out; }
  @keyframes growPop { 0%,100% { transform: scale(1); } 50% { transform: scale(1.2); } }
  #game-view { flex: 1; display: flex; flex-direction: column; align-items: center; }
  #canvas-wrap { flex: 1; display: flex; align-items: flex-end; justify-content: center; min-height: 280px; }
  canvas { display: block; max-width: 100%; }
  #controls { padding: 16px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .action-btn {
    padding: 14px 24px; border: none; border-radius: 14px; font-size: 1rem; font-weight: 700;
    cursor: pointer; color: white; box-shadow: 0 4px 12px var(--shadow);
    background: linear-gradient(135deg, #2196F3, #0D47A1);
  }
  .action-btn:active { transform: scale(0.96); }
  #progress-wrap { width: 100%; max-width: 320px; margin: 8px auto; height: 10px; background: var(--card); border-radius: 10px; overflow: hidden; }
  #progress-bar { height: 100%; background: linear-gradient(90deg, #FF6B35, #FFD700); border-radius: 10px; transition: width 0.5s; }
</style>
</head>
<body>
<div id="app">
  <div id="header">
    <h1>üå± Grow Your Dick</h1>
    <div id="size-display">–¢–≤—ñ–π —á–ª–µ–Ω: <span id="length-val">0.0</span> —Å–º</div>
  </div>
  <div id="progress-wrap"><div id="progress-bar" style="width:0%"></div></div>
  <div id="game-view">
    <div id="canvas-wrap"><canvas id="gameCanvas"></canvas></div>
    <div id="controls">
      <button class="action-btn" onclick="doWater()">üíß –ü–æ–ª–∏—Ç–∏</button>
      <button class="action-btn" onclick="doShave()">‚úÇÔ∏è –ì–æ–ª—ñ—Ç–∏</button>
    </div>
  </div>
</div>

<script>
const BASE_GROWTH = 0.5;
const MAX_LENGTH = 50;
const WATER_BONUS = 5;
const SHAVE_BONUS = 2;
const WATER_CD = 4 * 3600 * 1000;
const SHAVE_CD = 30 * 60 * 1000;

let state = { length: 1, lastSaved: Date.now(), lastWater: 0, lastShave: 0 };
let displayLength = 1;
let growthBurst = 0;

function saveLocal() { localStorage.setItem('gyd', JSON.stringify(state)); }
function loadLocal() { try { const d = localStorage.getItem('gyd'); return d ? JSON.parse(d) : null; } catch(e) { return null; } }

function applyOfflineGrowth() {
  const elapsed = Math.min(Date.now() - state.lastSaved, 24 * 3600000);
  if (elapsed <= 0) return;
  const hours = elapsed / 3600000;
  state.length = Math.min(MAX_LENGTH, state.length + hours * BASE_GROWTH);
  state.lastSaved = Date.now();
}

function canWater() { return Date.now() - state.lastWater >= WATER_CD; }
function canShave() { return Date.now() - state.lastShave >= SHAVE_CD; }

function doWater() {
  if (!canWater()) return;
  state.length = Math.min(MAX_LENGTH, state.length + WATER_BONUS);
  state.lastWater = Date.now();
  state.lastSaved = Date.now();
  growthBurst = 1;
  document.getElementById('length-val').classList.add('grow-pop');
  setTimeout(() => document.getElementById('length-val').classList.remove('grow-pop'), 400);
  saveLocal();
}

function doShave() {
  if (!canShave()) return;
  state.length = Math.min(MAX_LENGTH, state.length + SHAVE_BONUS);
  state.lastShave = Date.now();
  state.lastSaved = Date.now();
  growthBurst = 1;
  document.getElementById('length-val').classList.add('grow-pop');
  setTimeout(() => document.getElementById('length-val').classList.remove('grow-pop'), 400);
  saveLocal();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –†–ï–ê–õ–Ü–°–¢–ò–ß–ù–ò–ô –ú–ê–õ–Æ–ù–û–ö: —á–ª–µ–Ω –∑ –≤–æ–ª–æ—Å—Å—è–º, —â–æ —Ä–æ—Å—Ç–µ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let wobble = 0;

function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  canvas.width = Math.min(wrap.clientWidth, 360);
  canvas.height = Math.min(wrap.clientHeight, 320);
}

function lerp(a, b, t) { return a + (b - a) * Math.min(1, Math.max(0, t)); }

function drawScene(len, burst) {
  burst = burst || 0;
  const W = canvas.width, H = canvas.height;
  if (!W || !H) return;
  ctx.clearRect(0, 0, W, H);

  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  const sky = ctx.createLinearGradient(0, 0, 0, H * 0.7);
  sky.addColorStop(0, isDark ? '#0d1b2a' : '#87CEEB');
  sky.addColorStop(1, isDark ? '#1a3a5c' : '#b8e0f0');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, H * 0.7);

  // –¢—Ä–∞–≤–∞ –≤–Ω–∏–∑—É
  const grassGrad = ctx.createLinearGradient(0, H * 0.72, 0, H);
  grassGrad.addColorStop(0, isDark ? '#2d5a27' : '#4CAF50');
  grassGrad.addColorStop(1, isDark ? '#1a3d15' : '#388E3C');
  ctx.fillStyle = grassGrad;
  ctx.fillRect(0, H * 0.72, W, H);

  const cx = W / 2;
  const baseY = H * 0.72;
  const t = Math.min(len / MAX_LENGTH, 1);

  // –†–æ–∑–º—ñ—Ä–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –¥–æ–≤–∂–∏–Ω–∏ (—Ä–æ—Å—Ç–µ)
  const shaftHeight = lerp(20, H * 0.6, t);
  const shaftWidth = lerp(6, 22, t);
  const headRadius = lerp(4, 14, t);
  const hairRadius = lerp(8, 20, t);  // –≤–æ–ª–æ—Å—Å—è —Ç–µ–∂ —Ä–æ—Å—Ç–µ
  wobble = wobble > 0 ? wobble - 0.1 : 0;
  const sway = Math.sin(wobble) * 3;

  // Burst-–µ—Ñ–µ–∫—Ç –ø—Ä–∏ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—ñ
  const scaleY = 1 + burst * 0.25;
  ctx.save();
  ctx.translate(cx, baseY);
  ctx.scale(1, scaleY);
  ctx.translate(-cx, -baseY);

  // ‚ïê‚ïê‚ïê –í–û–õ–û–°–°–Ø (–ø—É–±—ñ—á–Ω–µ) ‚Äî —Ç–µ–º–Ω—ñ –∑–∞–≤–∏—Ç–∫–∏ –±—ñ–ª—è –æ—Å–Ω–æ–≤–∏ ‚ïê‚ïê‚ïê
  ctx.save();
  ctx.globalAlpha = 0.85;
  const hairColor = isDark ? '#3d2914' : '#5c4033';
  const hairCount = Math.floor(12 + t * 8);
  for (let i = 0; i < hairCount; i++) {
    const angle = (i / hairCount) * Math.PI * 1.2 + Math.random() * 0.3;
    const r = hairRadius * (0.5 + Math.random() * 0.5);
    const hx = cx + Math.cos(angle) * r * 0.8 + (Math.random() - 0.5) * 4;
    const hy = baseY - Math.sin(angle) * r * 0.3 + (Math.random() - 0.5) * 6;
    const hr = 2 + Math.random() * 3;
    ctx.fillStyle = hairColor;
    ctx.beginPath();
    ctx.ellipse(hx, hy, hr, hr * 1.4, angle * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // ‚ïê‚ïê‚ïê –¢—ñ–Ω—å –ø—ñ–¥ —á–ª–µ–Ω–æ–º ‚ïê‚ïê‚ïê
  ctx.beginPath();
  ctx.ellipse(cx + 2, baseY + 4, shaftWidth * 0.9, 4, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fill();

  // ‚ïê‚ïê‚ïê –°–¢–í–û–õ (—Å—Ç–≤–æ–ª) ‚Äî —Ä–µ–∞–ª—ñ—Å—Ç–∏—á–Ω–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç —à–∫—ñ—Ä–∏ ‚ïê‚ïê‚ïê
  const topY = baseY - shaftHeight;
  const shaftGrad = ctx.createLinearGradient(cx - shaftWidth, topY, cx + shaftWidth, baseY);
  shaftGrad.addColorStop(0, '#c17b5c');
  shaftGrad.addColorStop(0.25, '#e8a080');
  shaftGrad.addColorStop(0.5, '#f0b090');
  shaftGrad.addColorStop(0.75, '#e8a080');
  shaftGrad.addColorStop(1, '#c17b5c');
  ctx.fillStyle = shaftGrad;

  ctx.beginPath();
  ctx.moveTo(cx - shaftWidth * 0.5 + sway, baseY);
  ctx.quadraticCurveTo(cx - shaftWidth * 0.7, baseY - shaftHeight * 0.4, cx - shaftWidth * 0.6, topY + headRadius);
  ctx.lineTo(cx, topY + headRadius * 0.3);
  ctx.quadraticCurveTo(cx + shaftWidth * 0.6, topY + headRadius, cx + shaftWidth * 0.7, baseY - shaftHeight * 0.4);
  ctx.quadraticCurveTo(cx + shaftWidth * 0.5 - sway, baseY, cx + shaftWidth * 0.5, baseY);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // ‚ïê‚ïê‚ïê –ì–û–õ–û–í–ö–ê ‚Äî —Ç—Ä–æ—Ö–∏ —Å–≤—ñ—Ç–ª—ñ—à–∞, –æ–∫—Ä—É–≥–ª–∞ ‚ïê‚ïê‚ïê
  ctx.beginPath();
  ctx.ellipse(cx, topY + headRadius * 0.5, headRadius, headRadius * 0.85, 0, 0, Math.PI * 2);
  const headGrad = ctx.createRadialGradient(cx - 2, topY, 0, cx, topY, headRadius);
  headGrad.addColorStop(0, '#f5c4a8');
  headGrad.addColorStop(1, '#e8a882');
  ctx.fillStyle = headGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.stroke();

  ctx.restore();
}

function updateUI() {
  document.getElementById('length-val').textContent = displayLength.toFixed(1);
  document.getElementById('progress-bar').style.width = Math.min(100, (displayLength / MAX_LENGTH) * 100) + '%';
  drawScene(displayLength, growthBurst);
}

function init() {
  try {
    const tg = window.Telegram?.WebApp;
    if (tg) {
      tg.ready();
      tg.expand();
      document.documentElement.setAttribute('data-theme', tg.colorScheme || 'light');
    }
  } catch(e) {}
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  const local = loadLocal();
  if (local && typeof local.length === 'number') {
    state = { ...state, ...local };
    state.length = Math.min(MAX_LENGTH, Math.max(0.5, state.length));
  }
  applyOfflineGrowth();
  state.lastSaved = Date.now();
  saveLocal();

  displayLength = state.length;
  updateUI();

  setInterval(() => {
    applyOfflineGrowth();
    saveLocal();
  }, 2000);

  requestAnimationFrame(function loop() {
    displayLength = lerp(displayLength, state.length, 0.1);
    growthBurst = Math.max(0, growthBurst - 0.025);
    updateUI();
    requestAnimationFrame(loop);
  });
}

init();
</script>
</body>
</html>
